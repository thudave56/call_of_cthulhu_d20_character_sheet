<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CoC d20 Character Sheet - Test Suite</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
      padding: 20px;
      color: #333;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 10px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
      overflow: hidden;
    }
    header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      text-align: center;
    }
    h1 {
      font-size: 2.5em;
      margin-bottom: 10px;
    }
    .subtitle {
      font-size: 1.1em;
      opacity: 0.9;
    }
    .controls {
      padding: 20px;
      background: #f8f9fa;
      border-bottom: 2px solid #dee2e6;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    button {
      padding: 12px 24px;
      font-size: 1em;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: 600;
    }
    .run-all {
      background: #28a745;
      color: white;
    }
    .run-all:hover {
      background: #218838;
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    .clear-btn {
      background: #6c757d;
      color: white;
    }
    .clear-btn:hover {
      background: #5a6268;
    }
    .export-btn {
      background: #007bff;
      color: white;
    }
    .export-btn:hover {
      background: #0056b3;
    }
    .stats {
      display: flex;
      gap: 20px;
      padding: 15px 20px;
      background: white;
      border-bottom: 1px solid #dee2e6;
    }
    .stat {
      text-align: center;
      flex: 1;
    }
    .stat-value {
      font-size: 2em;
      font-weight: bold;
      margin-bottom: 5px;
    }
    .stat-label {
      color: #6c757d;
      font-size: 0.9em;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .passed { color: #28a745; }
    .failed { color: #dc3545; }
    .pending { color: #ffc107; }
    .results {
      padding: 20px;
    }
    .test-category {
      margin-bottom: 30px;
      border: 1px solid #dee2e6;
      border-radius: 8px;
      overflow: hidden;
    }
    .category-header {
      background: #f8f9fa;
      padding: 15px 20px;
      font-weight: bold;
      font-size: 1.2em;
      color: #495057;
      cursor: pointer;
      user-select: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .category-header:hover {
      background: #e9ecef;
    }
    .category-body {
      padding: 15px;
    }
    .test-case {
      padding: 15px;
      margin-bottom: 10px;
      border-left: 4px solid #dee2e6;
      background: #f8f9fa;
      border-radius: 4px;
      transition: all 0.3s ease;
    }
    .test-case.passed {
      border-left-color: #28a745;
      background: #d4edda;
    }
    .test-case.failed {
      border-left-color: #dc3545;
      background: #f8d7da;
    }
    .test-case.running {
      border-left-color: #007bff;
      background: #cfe2ff;
      animation: pulse 1s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    .test-name {
      font-weight: bold;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .test-status {
      font-size: 1.2em;
    }
    .test-description {
      color: #6c757d;
      font-size: 0.9em;
      margin-bottom: 8px;
    }
    .test-details {
      font-size: 0.85em;
      color: #495057;
      margin-top: 10px;
      padding: 10px;
      background: white;
      border-radius: 4px;
    }
    .test-error {
      color: #dc3545;
      font-family: 'Courier New', monospace;
      font-size: 0.85em;
      margin-top: 10px;
      padding: 10px;
      background: #fff5f5;
      border: 1px solid #dc3545;
      border-radius: 4px;
      white-space: pre-wrap;
    }
    .collapse-icon {
      transition: transform 0.3s ease;
    }
    .collapsed .collapse-icon {
      transform: rotate(-90deg);
    }
    .progress-bar {
      height: 6px;
      background: #e9ecef;
      position: relative;
      overflow: hidden;
    }
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #28a745, #20c997);
      transition: width 0.3s ease;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Call of Cthulhu d20 Character Sheet</h1>
      <p class="subtitle">Comprehensive Test Suite</p>
    </header>

    <div class="controls">
      <button class="run-all" onclick="runAllTests()">▶ Run All Tests</button>
      <button class="clear-btn" onclick="clearResults()">Clear Results</button>
      <button class="export-btn" onclick="exportResults()">Export Results</button>
    </div>

    <div class="progress-bar">
      <div class="progress-fill" id="progressFill" style="width: 0%"></div>
    </div>

    <div class="stats">
      <div class="stat">
        <div class="stat-value passed" id="passedCount">0</div>
        <div class="stat-label">Passed</div>
      </div>
      <div class="stat">
        <div class="stat-value failed" id="failedCount">0</div>
        <div class="stat-label">Failed</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="totalCount">0</div>
        <div class="stat-label">Total</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="duration">0ms</div>
        <div class="stat-label">Duration</div>
      </div>
    </div>

    <div class="results" id="results">
      <p style="text-align: center; color: #6c757d; padding: 40px;">
        Click "Run All Tests" to begin testing
      </p>
    </div>
  </div>

  <script>
    // Test framework
    const testResults = [];
    let startTime;

    class TestSuite {
      constructor(name) {
        this.name = name;
        this.tests = [];
      }

      addTest(name, description, testFn) {
        this.tests.push({ name, description, testFn });
      }
    }

    function assert(condition, message) {
      if (!condition) {
        throw new Error(message || 'Assertion failed');
      }
    }

    function assertEqual(actual, expected, message) {
      if (actual !== expected) {
        throw new Error(message || `Expected ${expected}, but got ${actual}`);
      }
    }

    function assertApprox(actual, expected, tolerance, message) {
      if (Math.abs(actual - expected) > tolerance) {
        throw new Error(message || `Expected ~${expected}, but got ${actual}`);
      }
    }

    // Create test iframe to load the actual application
    let testFrame;
    let testDoc;
    let testWindow;

    function setupTestEnvironment() {
      if (testFrame) {
        document.body.removeChild(testFrame);
      }
      testFrame = document.createElement('iframe');
      testFrame.style.display = 'none';
      testFrame.style.width = '1200px';
      testFrame.style.height = '800px';
      document.body.appendChild(testFrame);

      return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error('Timeout loading index.html'));
        }, 10000);

        testFrame.onload = () => {
          clearTimeout(timeout);
          testDoc = testFrame.contentDocument;
          testWindow = testFrame.contentWindow;

          // Wait a bit for scripts to initialize
          setTimeout(() => {
            if (!testDoc || !testDoc.body) {
              reject(new Error('Failed to load document'));
            } else {
              resolve();
            }
          }, 500);
        };

        testFrame.onerror = (error) => {
          clearTimeout(timeout);
          reject(new Error('Failed to load index.html: ' + error));
        };

        testFrame.src = 'index.html';
      });
    }

    // Wait for element to be available
    function waitForElement(selector, timeout = 5000) {
      return new Promise((resolve, reject) => {
        const startTime = Date.now();
        const check = () => {
          const el = testDoc.querySelector(selector);
          if (el) {
            resolve(el);
          } else if (Date.now() - startTime > timeout) {
            reject(new Error(`Timeout waiting for element: ${selector}`));
          } else {
            setTimeout(check, 50);
          }
        };
        check();
      });
    }

    // Helper to set input value
    function setInput(selector, value) {
      const el = testDoc.querySelector(selector);
      if (!el) throw new Error(`Element not found: ${selector}`);
      el.value = value;
      el.dispatchEvent(new Event('input', { bubbles: true }));
      el.dispatchEvent(new Event('change', { bubbles: true }));
    }

    // Helper to get text content
    function getText(selector) {
      const el = testDoc.querySelector(selector);
      if (!el) throw new Error(`Element not found: ${selector}`);
      return el.textContent.trim();
    }

    // Helper to click element
    function click(selector) {
      const el = testDoc.querySelector(selector);
      if (!el) throw new Error(`Element not found: ${selector}`);
      el.click();
    }

    // Define test suites
    const suites = [];

    // ==================== ABILITY SCORES ====================
    const abilitySuite = new TestSuite('Ability Scores & Modifiers');

    abilitySuite.addTest(
      'Ability Modifier Calculation',
      'Verify that ability modifiers are calculated correctly using (score - 10) / 2',
      async () => {
        await waitForElement('#abilitiesBody');

        // Test STR modifier
        setInput('[data-ability="Str"]', '15');
        await new Promise(resolve => setTimeout(resolve, 100));
        const strMod = getText('[data-ability="Str"].ability-mod');
        assertEqual(strMod, '+2', 'STR 15 should give +2 modifier');

        // Test low ability
        setInput('[data-ability="Dex"]', '8');
        await new Promise(resolve => setTimeout(resolve, 100));
        const dexMod = getText('[data-ability="Dex"].ability-mod');
        assertEqual(dexMod, '-1', 'DEX 8 should give -1 modifier');
      }
    );

    abilitySuite.addTest(
      'All Six Abilities Present',
      'Ensure all six ability scores (STR, DEX, CON, INT, WIS, CHA) are rendered',
      async () => {
        await waitForElement('#abilitiesBody');
        const abilities = ['Str', 'Dex', 'Con', 'Int', 'Wis', 'Cha'];
        for (const ability of abilities) {
          const input = testDoc.querySelector(`[data-ability="${ability}"]`);
          assert(input, `${ability} input should exist`);
        }
      }
    );

    suites.push(abilitySuite);

    // ==================== SAVING THROWS ====================
    const savesSuite = new TestSuite('Saving Throws');

    savesSuite.addTest(
      'Good vs Bad Save Progression',
      'Verify that good saves progress as 2 + level/2, bad saves as level/3',
      async () => {
        await waitForElement('#level');
        setInput('#level', '3');

        // Set offense (1 good save)
        setInput('#attackOption', 'offense');

        // Make Fort good
        const goodFort = testDoc.querySelector('#goodFort');
        if (!goodFort.checked) goodFort.click();

        await new Promise(resolve => setTimeout(resolve, 200));

        const fortSave = getText('#fortSave');
        // Good save at level 3: 2 + floor(3/2) = 2 + 1 = 3
        assert(fortSave.includes('+3') || fortSave.includes('3'), 'Fort save should be +3 at level 3 (good)');
      }
    );

    savesSuite.addTest(
      'Attack Option Constrains Good Saves',
      'Verify that offense allows 1 good save, defense allows 2',
      async () => {
        await waitForElement('#attackOption');
        setInput('#attackOption', 'offense');
        await new Promise(resolve => setTimeout(resolve, 100));

        // Try to check all three saves
        const saves = ['goodFort', 'goodRef', 'goodWill'];
        for (const saveId of saves) {
          const cb = testDoc.querySelector(`#${saveId}`);
          if (!cb.checked) cb.click();
        }

        await new Promise(resolve => setTimeout(resolve, 100));

        // Count checked saves
        const checkedCount = saves.filter(id => testDoc.querySelector(`#${id}`).checked).length;
        assertEqual(checkedCount, 1, 'Offense should only allow 1 good save');
      }
    );

    suites.push(savesSuite);

    // ==================== BASE ATTACK BONUS ====================
    const babSuite = new TestSuite('Base Attack Bonus');

    babSuite.addTest(
      'Offense Attack Progression',
      'Verify that offense option grants full BAB (equal to level)',
      async () => {
        await waitForElement('#level');
        setInput('#level', '5');
        setInput('#attackOption', 'offense');
        await new Promise(resolve => setTimeout(resolve, 200));

        const bab = getText('#baseAttack');
        assert(bab.includes('+5'), 'Offense BAB should be +5 at level 5');
      }
    );

    babSuite.addTest(
      'Defense Attack Progression',
      'Verify that defense option grants half BAB (level / 2)',
      async () => {
        await waitForElement('#level');
        setInput('#level', '6');
        setInput('#attackOption', 'defense');
        await new Promise(resolve => setTimeout(resolve, 200));

        const bab = getText('#baseAttack');
        assert(bab.includes('+3'), 'Defense BAB should be +3 at level 6');
      }
    );

    suites.push(babSuite);

    // ==================== SANITY SYSTEM ====================
    const sanitySuite = new TestSuite('Sanity System');

    sanitySuite.addTest(
      'Starting Sanity = WIS × 5',
      'Verify starting sanity equals Wisdom score multiplied by 5',
      async () => {
        await waitForElement('[data-ability="Wis"]');
        setInput('[data-ability="Wis"]', '14');
        await new Promise(resolve => setTimeout(resolve, 200));

        const startingSan = getText('#sanityStarting');
        assertEqual(startingSan, '70', 'Starting sanity should be 70 (14 × 5)');
      }
    );

    sanitySuite.addTest(
      'Maximum Sanity = 99 - Cthulhu Mythos Ranks',
      'Verify max sanity decreases with Cthulhu Mythos skill',
      async () => {
        await waitForElement('#skillsBody');

        // Set high level to avoid skill point limits
        setInput('#level', '5');
        setInput('[data-ability="Int"]', '14'); // +2 Int for more skill points
        await new Promise(resolve => setTimeout(resolve, 200));

        // Find Cthulhu Mythos skill row
        const rows = Array.from(testDoc.querySelectorAll('#skillsBody tr'));
        const mythosRow = rows.find(row => {
          const nameCell = row.querySelector('.skill-name');
          return nameCell && nameCell.textContent.includes('Cthulhu Mythos');
        });
        assert(mythosRow, 'Cthulhu Mythos skill should exist');

        const ranksInput = mythosRow.querySelector('.skill-ranks');
        assert(ranksInput, 'Cthulhu Mythos ranks input should exist');

        // Mark as core skill to reduce cost
        const coreCheckbox = mythosRow.querySelector('.skill-core-checkbox');
        if (coreCheckbox && !coreCheckbox.disabled) {
          coreCheckbox.checked = true;
          coreCheckbox.dispatchEvent(new Event('change', { bubbles: true }));
          await new Promise(resolve => setTimeout(resolve, 100));
        }

        ranksInput.value = '3';
        ranksInput.dispatchEvent(new Event('input', { bubbles: true }));
        ranksInput.dispatchEvent(new Event('change', { bubbles: true }));

        // Wait for validation to complete
        await new Promise(resolve => setTimeout(resolve, 300));

        // Verify the value stuck (wasn't reset by validation)
        const actualValue = ranksInput.value;
        assert(actualValue === '3', `Ranks input should be 3, got ${actualValue} (validation may have blocked it)`);

        // Manually trigger update functions
        if (testWindow.updateSkillsTotals) testWindow.updateSkillsTotals();
        if (testWindow.updateSanity) testWindow.updateSanity();
        if (testWindow.updateDerivedStats) testWindow.updateDerivedStats();

        await new Promise(resolve => setTimeout(resolve, 500));

        const maxSan = getText('#sanityMax');
        assertEqual(maxSan, '96', `Max sanity should be 96 (99 - 3), got ${maxSan}`);
      }
    );

    suites.push(sanitySuite);

    // ==================== SKILLS SYSTEM ====================
    const skillsSuite = new TestSuite('Skills System');

    skillsSuite.addTest(
      'Skill Total = Ranks + Ability Mod + Misc',
      'Verify skill totals are calculated correctly',
      async () => {
        await waitForElement('#skillsBody');

        // Set DEX to 16 (modifier +3)
        setInput('[data-ability="Dex"]', '16');
        await new Promise(resolve => setTimeout(resolve, 100));

        // Find a DEX-based skill (e.g., Hide)
        const rows = Array.from(testDoc.querySelectorAll('#skillsBody tr'));
        const hideRow = rows.find(row => row.textContent.includes('Hide'));

        if (hideRow) {
          const ranksInput = hideRow.querySelector('.skill-ranks');
          const miscInput = hideRow.querySelector('.skill-misc');
          const totalCell = hideRow.querySelector('.skill-total');

          ranksInput.value = '5';
          miscInput.value = '2';
          ranksInput.dispatchEvent(new Event('input', { bubbles: true }));
          ranksInput.dispatchEvent(new Event('change', { bubbles: true }));
          miscInput.dispatchEvent(new Event('input', { bubbles: true }));
          miscInput.dispatchEvent(new Event('change', { bubbles: true }));

          // Manually trigger update functions
          if (testWindow.updateSkillsTotals) testWindow.updateSkillsTotals();

          await new Promise(resolve => setTimeout(resolve, 500));

          const total = totalCell.textContent.trim().replace(/^\+/, ''); // Remove leading +
          // 5 ranks + 3 (DEX) + 2 misc = 10
          assertEqual(total, '10', `Hide total should be 10 (5 + 3 + 2), got ${total}`);
        }
      }
    );

    skillsSuite.addTest(
      'Profession Core Skills Highlighted',
      'Verify that profession core skills receive special styling',
      async () => {
        await waitForElement('#profession');

        // Select a profession (e.g., index 0)
        setInput('#profession', '0');
        await new Promise(resolve => setTimeout(resolve, 200));

        // Check if any skills have profession-skill class
        const profSkills = testDoc.querySelectorAll('.profession-skill');
        assert(profSkills.length > 0, 'Profession should have highlighted core skills');
      }
    );

    suites.push(skillsSuite);

    // ==================== FEATS SYSTEM ====================
    const featsSuite = new TestSuite('Feats System');

    featsSuite.addTest(
      'Feat Bonuses Applied to Saves',
      'Verify Great Fortitude grants +2 to Fortitude save',
      async () => {
        await waitForElement('#featsContainer');
        setInput('#level', '1');
        setInput('#attackOption', 'offense');

        // Uncheck all good saves first
        ['goodFort', 'goodRef', 'goodWill'].forEach(id => {
          const cb = testDoc.querySelector(`#${id}`);
          if (cb.checked) cb.click();
        });

        await new Promise(resolve => setTimeout(resolve, 100));

        // Get baseline Fort save
        const baselineSave = getText('#fortSave');

        // Find and check Great Fortitude feat
        const feats = Array.from(testDoc.querySelectorAll('#featsContainer input[type="checkbox"]'));
        const greatFort = feats.find(cb => {
          const label = cb.parentElement;
          return label && label.textContent.includes('Great Fortitude');
        });

        if (greatFort) {
          greatFort.click();
          await new Promise(resolve => setTimeout(resolve, 200));

          const newSave = getText('#fortSave');
          // Should increase by 2
          assert(newSave !== baselineSave, 'Great Fortitude should modify Fort save');
        }
      }
    );

    featsSuite.addTest(
      'Toughness Feat Grants +3 HP',
      'Verify Toughness feat adds 3 hit points',
      async () => {
        await waitForElement('#featsContainer');

        // Find Toughness feat
        const feats = Array.from(testDoc.querySelectorAll('#featsContainer input[type="checkbox"]'));
        const toughness = feats.find(cb => {
          const label = cb.parentElement;
          return label && label.textContent.includes('Toughness');
        });

        if (toughness && !toughness.checked) {
          toughness.click();
          await new Promise(resolve => setTimeout(resolve, 200));

          const hpNote = getText('#hpBonusNote');
          assert(hpNote.includes('+3'), 'HP bonus note should mention +3 from Toughness');
        }
      }
    );

    suites.push(featsSuite);

    // ==================== EQUIPMENT SYSTEM ====================
    const equipmentSuite = new TestSuite('Equipment & Combat');

    equipmentSuite.addTest(
      'Add and Remove Weapons',
      'Verify weapons can be added and removed from inventory',
      async () => {
        await waitForElement('#addWeaponBtn');

        const addBtn = testDoc.querySelector('#addWeaponBtn');
        const tbody = testDoc.querySelector('#weaponsBody');

        // Count actual weapon rows (not placeholder text)
        const initialRows = Array.from(tbody.querySelectorAll('tr')).filter(tr => {
          return tr.querySelector('.weapon-input') !== null;
        });
        const initialCount = initialRows.length;

        addBtn.click();
        await new Promise(resolve => setTimeout(resolve, 300));

        const newRows = Array.from(tbody.querySelectorAll('tr')).filter(tr => {
          return tr.querySelector('.weapon-input') !== null;
        });
        const newCount = newRows.length;

        assert(newCount === initialCount + 1, `Weapon should be added to table (was ${initialCount}, now ${newCount})`);
      }
    );

    equipmentSuite.addTest(
      'Armor Class Calculation',
      'Verify AC = 10 + armor + shield + DEX (capped)',
      async () => {
        await waitForElement('#armorBonus');

        // Set DEX to 16 (mod +3)
        setInput('[data-ability="Dex"]', '16');
        setInput('#armorBonus', '2');
        setInput('#shieldBonus', '1');

        await new Promise(resolve => setTimeout(resolve, 200));

        const ac = getText('#acValue');
        // 10 + 2 + 1 + 3 = 16
        assertEqual(ac, '16', 'AC should be 16');
      }
    );

    equipmentSuite.addTest(
      'Armor Max Dex Cap',
      'Verify that armor max dex bonus caps dexterity contribution to AC',
      async () => {
        await waitForElement('#armorBonus');

        // Set high DEX
        setInput('[data-ability="Dex"]', '18'); // +4 mod
        setInput('#armorBonus', '5');
        setInput('#shieldBonus', '0'); // No shield
        setInput('#armorMaxDex', '2'); // Cap at +2

        await new Promise(resolve => setTimeout(resolve, 500));

        const ac = getText('#acValue');
        // 10 + 5 + 0 + 2 (capped DEX) = 17
        assertEqual(ac, '17', `AC should be 17 with capped DEX (got ${ac})`);
      }
    );

    equipmentSuite.addTest(
      'Encumbrance Calculation',
      'Verify total weight includes weapons, equipment, and armor',
      async () => {
        await waitForElement('#addWeaponBtn');

        // Add weapon with weight
        click('#addWeaponBtn');
        await new Promise(resolve => setTimeout(resolve, 100));

        const weightInput = testDoc.querySelector('#weaponsBody input[data-field="weight"]');
        if (weightInput) {
          weightInput.value = '5';
          weightInput.dispatchEvent(new Event('change', { bubbles: true }));
          await new Promise(resolve => setTimeout(resolve, 200));

          const totalWeight = getText('#totalWeight');
          assert(parseFloat(totalWeight) >= 5, 'Total weight should include weapon');
        }
      }
    );

    equipmentSuite.addTest(
      'Initiative Equals DEX Modifier',
      'Verify initiative is set to dexterity modifier',
      async () => {
        await waitForElement('[data-ability="Dex"]');

        setInput('[data-ability="Dex"]', '14'); // +2 mod
        await new Promise(resolve => setTimeout(resolve, 200));

        const init = getText('#initValue');
        assertEqual(init, '+2', 'Initiative should equal DEX modifier');
      }
    );

    suites.push(equipmentSuite);

    // ==================== SAVE/LOAD SYSTEM ====================
    const storageSuite = new TestSuite('Save/Load System');

    storageSuite.addTest(
      'Save Character to LocalStorage',
      'Verify character can be saved with all data',
      async () => {
        await waitForElement('#charName');

        const testName = 'TestChar_' + Date.now();
        setInput('#charName', testName);
        setInput('[data-ability="Str"]', '17'); // Different from other tests
        setInput('#level', '3');

        await new Promise(resolve => setTimeout(resolve, 100));

        click('#saveButton');
        await new Promise(resolve => setTimeout(resolve, 500));

        // Check localStorage
        const stored = JSON.parse(testWindow.localStorage.getItem('cocd20_characters') || '{}');
        assert(stored[testName], 'Character should be saved in localStorage');
        assertEqual(stored[testName].abilities.Str, '17', 'STR should be saved');

        // Cleanup - reset STR back to 10
        setInput('[data-ability="Str"]', '10');
        delete stored[testName];
        testWindow.localStorage.setItem('cocd20_characters', JSON.stringify(stored));
      }
    );

    storageSuite.addTest(
      'Load Character from LocalStorage',
      'Verify character can be loaded and all fields populated',
      async () => {
        await waitForElement('#charName');

        // Clean up any leftover test characters first
        const preCleanup = JSON.parse(testWindow.localStorage.getItem('cocd20_characters') || '{}');
        Object.keys(preCleanup).forEach(key => {
          if (key.startsWith('EquipTest_') || key.startsWith('LoadTest_') || key.startsWith('TestChar_') || key.startsWith('SaveTest_')) {
            delete preCleanup[key];
          }
        });
        testWindow.localStorage.setItem('cocd20_characters', JSON.stringify(preCleanup));

        const testName = 'LoadTest_' + Date.now();

        // First, reset all abilities to 10 to ensure clean state
        const abilities = ['Str', 'Dex', 'Con', 'Int', 'Wis', 'Cha'];
        for (const ability of abilities) {
          setInput(`[data-ability="${ability}"]`, '10');
        }
        await new Promise(resolve => setTimeout(resolve, 200));

        // Manually save a character
        const testChar = {
          playerName: 'Test Player',
          level: '5',
          abilities: { Str: '18', Dex: '14', Con: '12', Int: '10', Wis: '13', Cha: '8' },
          skills: [],
          feats: [],
          attackOption: 'offense',
          goodSaves: { fort: true, ref: false, will: false },
          era: '1921-1940',
          hitPoints: '35',
          currentHP: '35',
          currentSanity: '65'
        };

        const stored = JSON.parse(testWindow.localStorage.getItem('cocd20_characters') || '{}');
        stored[testName] = testChar;
        testWindow.localStorage.setItem('cocd20_characters', JSON.stringify(stored));

        // Reload character list
        testWindow.populateSavedCharacters();
        await new Promise(resolve => setTimeout(resolve, 300));

        // Intercept alert from load
        const originalAlert = testWindow.alert;
        testWindow.alert = () => {};

        // Select and load
        setInput('#characterSelect', testName);
        click('#loadButton');
        await new Promise(resolve => setTimeout(resolve, 1000));

        // Restore alert
        testWindow.alert = originalAlert;

        // Verify loaded data
        const loadedName = testDoc.querySelector('#charName').value;
        const loadedStr = testDoc.querySelector('[data-ability="Str"]').value;

        assertEqual(loadedName, testName, `Character name should match (got ${loadedName})`);
        assertEqual(loadedStr, '18', `STR should be loaded correctly (got ${loadedStr})`);

        // Cleanup
        delete stored[testName];
        testWindow.localStorage.setItem('cocd20_characters', JSON.stringify(stored));
      }
    );

    storageSuite.addTest(
      'Equipment Persists in Save/Load',
      'Verify weapons and equipment are saved and loaded',
      async () => {
        await waitForElement('#charName');

        // Clean up any leftover test characters first
        const preCleanup = JSON.parse(testWindow.localStorage.getItem('cocd20_characters') || '{}');
        Object.keys(preCleanup).forEach(key => {
          if (key.startsWith('EquipTest_') || key.startsWith('LoadTest_') || key.startsWith('TestChar_') || key.startsWith('SaveTest_')) {
            delete preCleanup[key];
          }
        });
        testWindow.localStorage.setItem('cocd20_characters', JSON.stringify(preCleanup));

        const testName = 'EquipTest_' + Date.now();

        // Use setInput helper for character name
        setInput('#charName', testName);

        // Set a profession to avoid undefined error
        setInput('#profession', '0');

        await new Promise(resolve => setTimeout(resolve, 200));

        // Verify the name was actually set
        const nameInput = testDoc.querySelector('#charName');
        assert(nameInput.value === testName, `Character name should be set to ${testName}, got ${nameInput.value}`);

        // Add a weapon
        click('#addWeaponBtn');
        await new Promise(resolve => setTimeout(resolve, 300));

        const weaponName = testDoc.querySelector('#weaponsBody input[data-field="name"]');
        if (weaponName) {
          weaponName.value = 'Test Sword';
          weaponName.dispatchEvent(new Event('change', { bubbles: true }));
          await new Promise(resolve => setTimeout(resolve, 100));
        }

        // Verify weapon is in the global array
        assert(testWindow.weapons && testWindow.weapons.length > 0, `Weapon should be in weapons array before save (got ${testWindow.weapons ? testWindow.weapons.length : 'undefined'})`);

        // Intercept alert to avoid blocking
        const originalAlert = testWindow.alert;
        testWindow.alert = () => {};

        // Call saveCharacter directly instead of clicking
        if (typeof testWindow.saveCharacter === 'function') {
          testWindow.saveCharacter();
        } else {
          // Fallback to clicking if function not available
          click('#saveButton');
        }
        await new Promise(resolve => setTimeout(resolve, 500));

        // Restore alert
        testWindow.alert = originalAlert;

        // Verify saved
        const stored = JSON.parse(testWindow.localStorage.getItem('cocd20_characters') || '{}');
        assert(stored[testName], `Character should be saved (got ${Object.keys(stored).join(', ')})`);
        if (stored[testName]) {
          assert(stored[testName].weapons, 'Weapons should be in saved data');
          assert(stored[testName].weapons.length > 0, 'Should have at least one weapon in saved data');
        }

        // Clear weapons to test load
        testWindow.weapons = [];
        if (testWindow.renderWeapons) testWindow.renderWeapons();
        await new Promise(resolve => setTimeout(resolve, 200));

        // Load - intercept alert again
        testWindow.alert = () => {};
        testWindow.populateSavedCharacters();
        await new Promise(resolve => setTimeout(resolve, 300));
        setInput('#characterSelect', testName);

        // Call loadCharacter directly
        if (typeof testWindow.loadCharacter === 'function') {
          testWindow.loadCharacter();
        } else {
          click('#loadButton');
        }
        await new Promise(resolve => setTimeout(resolve, 500));
        testWindow.alert = originalAlert;

        // Verify weapon loaded
        assert(testWindow.weapons && testWindow.weapons.length > 0, `Weapons should be loaded (got ${testWindow.weapons ? testWindow.weapons.length : 'undefined'})`);

        // Cleanup
        const cleanup = JSON.parse(testWindow.localStorage.getItem('cocd20_characters') || '{}');
        delete cleanup[testName];
        testWindow.localStorage.setItem('cocd20_characters', JSON.stringify(cleanup));
      }
    );

    suites.push(storageSuite);

    // ==================== PROFESSION SYSTEM ====================
    const professionSuite = new TestSuite('Profession System');

    professionSuite.addTest(
      'Profession Dropdown Populated',
      'Verify profession dropdown has all 16 professions',
      async () => {
        await waitForElement('#profession');
        const options = testDoc.querySelectorAll('#profession option');
        assert(options.length >= 16, 'Should have at least 16 professions');
      }
    );

    professionSuite.addTest(
      'Profession Info Displays',
      'Verify selecting a profession shows description and core skills',
      async () => {
        await waitForElement('#profession');
        setInput('#profession', '0');
        await new Promise(resolve => setTimeout(resolve, 200));

        const profInfo = testDoc.querySelector('#profession-info');
        assert(profInfo && profInfo.textContent.length > 0, 'Profession info should be displayed');
      }
    );

    suites.push(professionSuite);

    // ==================== RUN TESTS ====================
    async function runAllTests() {
      testResults.length = 0;
      startTime = Date.now();

      const resultsDiv = document.getElementById('results');
      resultsDiv.innerHTML = '';

      updateStats();

      let setupError = null;
      try {
        await setupTestEnvironment();
      } catch (error) {
        setupError = error;
        resultsDiv.innerHTML = `
          <div style="padding: 40px; text-align: center;">
            <h2 style="color: #dc3545;">❌ Test Environment Setup Failed</h2>
            <p style="color: #6c757d; margin: 20px 0;">Could not load index.html into test frame.</p>
            <div style="background: #f8d7da; border: 1px solid #dc3545; border-radius: 8px; padding: 15px; margin: 20px auto; max-width: 600px; text-align: left;">
              <strong>Error:</strong><br>
              <code style="color: #721c24;">${error.message}</code>
            </div>
            <p style="color: #6c757d;">
              <strong>Troubleshooting:</strong><br>
              • Ensure index.html is in the same directory as test_suite.html<br>
              • Check browser console (F12) for JavaScript errors<br>
              • Verify all script files are present (script.js, equipment_functions.js)<br>
              • Try opening index.html directly to see if it loads
            </p>
          </div>
        `;
        return;
      }

      try {
        // Wait for app to initialize
        await new Promise(resolve => setTimeout(resolve, 1000));

        for (const suite of suites) {
          const categoryDiv = document.createElement('div');
          categoryDiv.className = 'test-category';

          const header = document.createElement('div');
          header.className = 'category-header';
          header.innerHTML = `
            <span>${suite.name} (0/${suite.tests.length})</span>
            <span class="collapse-icon">▼</span>
          `;

          const body = document.createElement('div');
          body.className = 'category-body';

          categoryDiv.appendChild(header);
          categoryDiv.appendChild(body);
          resultsDiv.appendChild(categoryDiv);

          header.onclick = () => {
            categoryDiv.classList.toggle('collapsed');
            body.style.display = body.style.display === 'none' ? 'block' : 'none';
          };

          let passedInCategory = 0;

          for (const test of suite.tests) {
            const testDiv = document.createElement('div');
            testDiv.className = 'test-case running';
            testDiv.innerHTML = `
              <div class="test-name">
                <span class="test-status">⏳</span>
                <span>${test.name}</span>
              </div>
              <div class="test-description">${test.description}</div>
            `;
            body.appendChild(testDiv);

            let result = { name: test.name, suite: suite.name, passed: false };

            try {
              await test.testFn();
              result.passed = true;
              passedInCategory++;
              testDiv.className = 'test-case passed';
              testDiv.querySelector('.test-status').textContent = '✓';
              testDiv.innerHTML += '<div class="test-details">✓ Test passed</div>';
            } catch (error) {
              result.passed = false;
              result.error = error.message;
              result.stack = error.stack;
              testDiv.className = 'test-case failed';
              testDiv.querySelector('.test-status').textContent = '✗';
              const errorMsg = error.message || 'Unknown error';
              const stackTrace = error.stack ? `\n\nStack:\n${error.stack}` : '';
              testDiv.innerHTML += `<div class="test-error">✗ ${errorMsg}${stackTrace}</div>`;
              console.error(`Test failed: ${test.name}`, error);
            }

            testResults.push(result);
            updateStats();
            header.querySelector('span:first-child').textContent =
              `${suite.name} (${passedInCategory}/${suite.tests.length})`;
          }
        }

      } catch (error) {
        alert('Error setting up test environment: ' + error.message);
      }
    }

    function updateStats() {
      const passed = testResults.filter(r => r.passed).length;
      const failed = testResults.filter(r => !r.passed).length;
      const total = testResults.length;
      const duration = Date.now() - (startTime || Date.now());

      document.getElementById('passedCount').textContent = passed;
      document.getElementById('failedCount').textContent = failed;
      document.getElementById('totalCount').textContent = total;
      document.getElementById('duration').textContent = duration + 'ms';

      const totalTests = suites.reduce((sum, suite) => sum + suite.tests.length, 0);
      const progress = totalTests > 0 ? (total / totalTests) * 100 : 0;
      document.getElementById('progressFill').style.width = progress + '%';
    }

    function clearResults() {
      testResults.length = 0;
      document.getElementById('results').innerHTML =
        '<p style="text-align: center; color: #6c757d; padding: 40px;">Click "Run All Tests" to begin testing</p>';
      updateStats();
    }

    function exportResults() {
      const report = {
        timestamp: new Date().toISOString(),
        duration: Date.now() - startTime,
        summary: {
          total: testResults.length,
          passed: testResults.filter(r => r.passed).length,
          failed: testResults.filter(r => !r.passed).length
        },
        results: testResults
      };

      const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `test-results-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
    }
  </script>
</body>
</html>
